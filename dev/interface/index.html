<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The AbstractSciMLOperator Interface · SciMLOperators.jl</title><meta name="title" content="The AbstractSciMLOperator Interface · SciMLOperators.jl"/><meta property="og:title" content="The AbstractSciMLOperator Interface · SciMLOperators.jl"/><meta property="twitter:title" content="The AbstractSciMLOperator Interface · SciMLOperators.jl"/><meta name="description" content="Documentation for SciMLOperators.jl."/><meta property="og:description" content="Documentation for SciMLOperators.jl."/><meta property="twitter:description" content="Documentation for SciMLOperators.jl."/><meta property="og:url" content="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><meta property="twitter:url" content="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><link rel="canonical" href="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SciMLOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SciMLOperators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/getting_started/">Getting Started with Matrix-Free Operators in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/operator_algebras/">Demonstration of Operator Algebras and Kron</a></li><li><a class="tocitem" href="../tutorials/fftw/">FFT Tutorial</a></li></ul></li><li class="is-active"><a class="tocitem" href>The <code>AbstractSciMLOperator</code> Interface</a><ul class="internal"><li><a class="tocitem" href="#Interface-API-Reference"><span>Interface API Reference</span></a></li><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#Note-About-Affine-Operators"><span>Note About Affine Operators</span></a></li><li><a class="tocitem" href="#Note-about-keyword-arguments-to-update_coefficients!"><span>Note about keyword arguments to <code>update_coefficients!</code></span></a></li></ul></li><li><a class="tocitem" href="../premade_operators/">Premade Operators</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The <code>AbstractSciMLOperator</code> Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The <code>AbstractSciMLOperator</code> Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLOperators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLOperators.jl/blob/master/docs/src/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="operator_interface"><a class="docs-heading-anchor" href="#operator_interface">The <code>AbstractSciMLOperator</code> Interface</a><a id="operator_interface-1"></a><a class="docs-heading-anchor-permalink" href="#operator_interface" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.AbstractSciMLOperator" href="#SciMLOperators.AbstractSciMLOperator"><code>SciMLOperators.AbstractSciMLOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSciMLOperator{T}</code></pre><p>Subtypes of <code>AbstractSciMLOperator</code> represent linear, nonlinear, time-dependent operators acting on vectors, or matrix column-vectors. A lazy operator algebra is also defined for <code>AbstractSciMLOperator</code>s.</p><p><strong>Mathematical Notation</strong></p><p>An <code>AbstractSciMLOperator</code> <span>$L$</span> is an operator which is used to represent the following type of equation:</p><p class="math-container">\[w = L(u,p,t)[v]\]</p><p>where <code>L[v]</code> is the operator application of <span>$L$</span> on the vector <span>$v$</span>.</p><p><strong>Interface</strong></p><p>An <code>AbstractSciMLOperator</code> can be called  like a function in the following ways:</p><ul><li><code>L(v, u, p, t)</code> - Out-of-place application where <code>v</code> is the action vector and <code>u</code> is the update vector</li><li><code>L(w, v, u, p, t)</code> - In-place application where <code>w</code> is the destination, <code>v</code> is the action vector, and <code>u</code> is the update vector</li><li><code>L(w, v, u, p, t, α, β)</code> - In-place application with scaling: <code>w = α*(L*v) + β*w</code></li></ul><p>Operator state can be updated separately from application:</p><ul><li><code>update_coefficients!(L, u, p, t)</code> for in-place operator update</li><li><code>L = update_coefficients(L, u, p, t)</code> for out-of-place operator update</li></ul><p>SciMLOperators also overloads <code>Base.*</code>, <code>LinearAlgebra.mul!</code>, <code>LinearAlgebra.ldiv!</code> for operator evaluation without updating operator state. An <code>AbstractSciMLOperator</code> behaves like a matrix in these methods. Allocation-free methods, suffixed with a <code>!</code> often need cache arrays. To precache an <code>AbstractSciMLOperator</code>, call the function <code>L = cache_operator(L, input_vector)</code>.</p><p><strong>Overloaded Actions</strong></p><p>The behavior of a <code>SciMLOperator</code> is indistinguishable from an <code>AbstractMatrix</code>. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the <code>AbstractMatrix</code> interface includes, but is not limited to, the following:</p><ul><li><code>Base: size, zero, one, +, -, *, /, \, ∘, inv, adjoint, transpose, convert</code></li><li><code>LinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef</code></li><li><code>SparseArrays: sparse, issparse</code></li></ul><p><strong>Multidimensional arrays and batching</strong></p><p>SciMLOperator can also be applied to <code>AbstractMatrix</code> subtypes where operator-evaluation is done column-wise.</p><pre><code class="language-julia hljs">K = 10
u_mat = rand(N, K)

v_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)
size(v_mat) == (N, K) # true</code></pre><p><code>L</code> can also be applied to <code>AbstractArray</code>s that are not <code>AbstractVecOrMat</code>s so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, <code>SciMLOperator</code>s reshapes an <code>N</code>-dimensional array to an <code>AbstractMatrix</code>, and applies the operator via matrix-multiplication.</p><p><strong>Operator update</strong></p><p>This package can also be used to write state-dependent, time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, <code>Zygote</code>-compatible way.</p><p>For example,</p><pre><code class="language-julia hljs">u = rand(N)
p = rand(N)
t = rand()

# out-of-place update
mat_update_func = (A, u, p, t) -&gt; t * (p * u&#39;)
sca_update_func = (a, u, p, t) -&gt; t * sum(p)

M = MatrixOperator(zero(N, N); update_func = mat_update_func)
α = ScalarOperator(zero(Float64); update_func = sca_update_func)

L = α * M
L = cache_operator(L, v)

# L is initialized with zero state
L * v == zeros(N) # true

# update operator state with `(u, p, t)`
L = update_coefficients(L, u, p, t)
# and multiply
L * v != zeros(N) # true

# updates state and evaluates L*v at (u, p, t)
L(v, u, p, t) != zeros(N) # true</code></pre><p>The out-of-place evaluation function <code>L(v, u, p, t)</code> calls <code>update_coefficients</code> under the hood, which recursively calls the <code>update_func</code> for each component <code>SciMLOperator</code>. Therefore, the out-of-place evaluation function is equivalent to calling <code>update_coefficients</code> followed by <code>Base.*</code>. Notice that the out-of-place evaluation does not return the updated operator.</p><p>On the other hand, the in-place evaluation function, <code>L(w, v, u, p, t)</code>, mutates <code>L</code>, and is equivalent to calling <code>update_coefficients!</code> followed by <code>mul!</code>. The in-place update behavior works the same way, with a few <code>&lt;!&gt;</code>s appended here and there. For example,</p><pre><code class="language-julia hljs">w = rand(N)
v = rand(N)
u = rand(N)
p = rand(N)
t = rand()

# in-place update
_A = rand(N, N)
_d = rand(N)
mat_update_func! = (A, u, p, t) -&gt; (copy!(A, _A); lmul!(t, A); nothing)
diag_update_func! = (diag, u, p, t) -&gt; copy!(diag, N)

M = MatrixOperator(zero(N, N); update_func! = mat_update_func!)
D = DiagonalOperator(zero(N); update_func! = diag_update_func!)

L = D * M
L = cache_operator(L, v)

# L is initialized with zero state
L * v == zeros(N) # true

# update L in-place
update_coefficients!(L, v, p, t)
# and multiply
mul!(w, v, u, p, t) != zero(N) # true

# updates L in-place, and evaluates w=L*v at (u, p, t)
L(w, v, u, p, t) != zero(N) # true</code></pre><p>The update behavior makes this package flexible enough to be used in <code>OrdinaryDiffEq</code>. As the parameter object <code>p</code> is often reserved for sensitivity computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow update functions with arbitrary keyword arguments.</p><pre><code class="language-julia hljs">mat_update_func = (A, u, p, t; scale = 0.0) -&gt; scale * (p * u&#39;)

M = MatrixOperator(zero(N, N); update_func = mat_update_func,
    accepted_kwargs = (:state,))

M(v, u, p, t) == zeros(N) # true
M(v, u, p, t; scale = 1.0) != zero(N)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/SciMLOperators.jl#L25">source</a></section></article><h2 id="Interface-API-Reference"><a class="docs-heading-anchor" href="#Interface-API-Reference">Interface API Reference</a><a id="Interface-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.update_coefficients" href="#SciMLOperators.update_coefficients"><code>SciMLOperators.update_coefficients</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_coefficients(L, u, p, t; kwargs...)
</code></pre><p>Update the state of <code>L</code> based on <code>u</code>, input vector, <code>p</code> parameter object, <code>t</code>, and keyword arguments. Internally, <code>update_coefficients</code> calls the user-provided <code>update_func</code> method for every component operator in <code>L</code> with the positional arguments <code>(u, p, t)</code> and keyword arguments corresponding to the symbols provided to the operator via kwarg <code>accepted_kwargs</code>.</p><p>This method is out-of-place, i.e. fully non-mutating and <code>Zygote</code>-compatible.</p><div class="admonition is-warning" id="Warning-5f9e16da8ee0c23"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-5f9e16da8ee0c23" title="Permalink"></a></header><div class="admonition-body"><p>The user-provided <code>update_func[!]</code> must not use <code>u</code> in its computation. Positional argument <code>(u, p, t)</code> to <code>update_func[!]</code> are passed down by <code>update_coefficients[!](L, u, p, t)</code>, where <code>u</code> is the input-vector to the composite <code>AbstractSciMLOperator</code>. For that reason, the values of <code>u</code>, or even shape, may not correspond to the input expected by <code>update_func[!]</code>. If an operator&#39;s state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in <code>FunctionOperator.</code> This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SciMLOperators

mat_update_func = (A, u, p, t; scale = 1.0) -&gt; p * p&#39; * scale * t

M = MatrixOperator(zeros(4,4); update_func = mat_update_func,
                   accepted_kwargs = (:state,))

L = M + IdentityOperator(4)

u = rand(4)
p = rand(4)
t = 1.0

# Update the operator to `(u,p,t)` and apply it to `v`
L = update_coefficients(L, u, p, t; scale = 2.0)
result = L * v

# Or use the interface which separrates the update from the application
result = L(v, u, p, t; scale = 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.update_coefficients!" href="#SciMLOperators.update_coefficients!"><code>SciMLOperators.update_coefficients!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_coefficients!(L, u, p, t; kwargs...)
</code></pre><p>Update in-place the state of <code>L</code> based on <code>u</code>, input vector, <code>p</code> parameter object, <code>t</code>, and keyword arguments. Internally, <code>update_coefficients!</code> calls the user-provided mutating <code>update_func!</code> method for every component operator in <code>L</code> with the positional arguments <code>(u, p, t)</code> and keyword arguments corresponding to the symbols provided to the operator via kwarg <code>accepted_kwargs</code>.</p><div class="admonition is-warning" id="Warning-5f9e16da8ee0c23"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-5f9e16da8ee0c23" title="Permalink"></a></header><div class="admonition-body"><p>The user-provided <code>update_func[!]</code> must not use <code>u</code> in its computation. Positional argument <code>(u, p, t)</code> to <code>update_func[!]</code> are passed down by <code>update_coefficients[!](L, u, p, t)</code>, where <code>u</code> is the input-vector to the composite <code>AbstractSciMLOperator</code>. For that reason, the values of <code>u</code>, or even shape, may not correspond to the input expected by <code>update_func[!]</code>. If an operator&#39;s state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in <code>FunctionOperator.</code> This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SciMLOperators

_A = rand(4, 4)
mat_update_func! = (L, u, p, t; scale = 1.0) -&gt; copy!(A, _A)

M = MatrixOperator(zeros(4,4); update_func! = mat_update_func!)

L = M + IdentityOperator(4)

u = rand(4)
p = rand(4)
t = 1.0

update_coefficients!(L, u, p, t)
L * v</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L69-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.cache_operator" href="#SciMLOperators.cache_operator"><code>SciMLOperators.cache_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cache_operator(L, u)
</code></pre><p>Allocate caches for <code>L</code> for in-place evaluation with <code>u</code>-like input vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.concretize" href="#SciMLOperators.concretize"><code>SciMLOperators.concretize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">concretize(L) -&gt; AbstractMatrix

concretize(L) -&gt; Number</code></pre><p>Convert <code>SciMLOperator</code> to a concrete type via eager fusion. This method is a no-op for types that are already concrete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L283-L290">source</a></section></article><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.isconstant" href="#SciMLOperators.isconstant"><code>SciMLOperators.isconstant</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconstant(_)
</code></pre><p>Checks if an <code>L</code>&#39;s state is constant or needs to be updated by calling <code>update_coefficients</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.iscached" href="#SciMLOperators.iscached"><code>SciMLOperators.iscached</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscached(L)
</code></pre><p>Checks whether <code>L</code> has preallocated caches for inplace evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L139">source</a></section><section><div><p>Check if <code>SciMLOperator</code> <code>L</code> has preallocated cache-arrays for in-place computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L151-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.issquare" href="#SciMLOperators.issquare"><code>SciMLOperators.issquare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Checks if <code>size(L, 1) == size(L, 2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L365-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.islinear" href="#SciMLOperators.islinear"><code>SciMLOperators.islinear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">islinear(_)
</code></pre><p>Checks if <code>L</code> is a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.isconvertible" href="#SciMLOperators.isconvertible"><code>SciMLOperators.isconvertible</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconvertible(L) -&gt; Bool</code></pre><p>Checks if <code>L</code> can be cheaply converted to an <code>AbstractMatrix</code> via eager fusion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_adjoint" href="#SciMLOperators.has_adjoint"><code>SciMLOperators.has_adjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_adjoint(L)
</code></pre><p>Check if <code>adjoint(L)</code> is lazily defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_expmv" href="#SciMLOperators.has_expmv"><code>SciMLOperators.has_expmv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_expmv(L)
</code></pre><p>Check if <code>expmv(L, v, t)</code>, equivalent to <code>exp(t * A) * v</code>, is defined for <code>Number</code> <code>t</code>, and <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_expmv!" href="#SciMLOperators.has_expmv!"><code>SciMLOperators.has_expmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_expmv!(L)
</code></pre><p>Check if <code>expmv!(w, L, v, t)</code>, equivalent to <code>mul!(w, exp(t * A), v)</code>, is defined for <code>Number</code> <code>t</code>, and <code>AbstractArray</code>s <code>w, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_exp" href="#SciMLOperators.has_exp"><code>SciMLOperators.has_exp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_exp(L)
</code></pre><p>Check if <code>exp(L)</code> is defined lazily defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_mul" href="#SciMLOperators.has_mul"><code>SciMLOperators.has_mul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_mul(L)
</code></pre><p>Check if <code>L * v</code> is defined for <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_mul!" href="#SciMLOperators.has_mul!"><code>SciMLOperators.has_mul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_mul!(L)
</code></pre><p>Check if <code>mul!(w, L, v)</code> is defined for <code>AbstractArray</code>s <code>w, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_ldiv" href="#SciMLOperators.has_ldiv"><code>SciMLOperators.has_ldiv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_ldiv(L)
</code></pre><p>Check if <code>L \ v</code> is defined for <code>AbstractArray</code> <code>v</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_ldiv!" href="#SciMLOperators.has_ldiv!"><code>SciMLOperators.has_ldiv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_ldiv!(L)
</code></pre><p>Check if <code>ldiv!(w, L, v)</code> is defined for <code>AbstractArray</code>s <code>w, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/4937fe46997295eb95c43647c8c872b8995b3b68/src/interface.jl#L237">source</a></section></article><h2 id="Note-About-Affine-Operators"><a class="docs-heading-anchor" href="#Note-About-Affine-Operators">Note About Affine Operators</a><a id="Note-About-Affine-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Note-About-Affine-Operators" title="Permalink"></a></h2><p>Affine operators are operators that have the action <code>Q*x = A*x + b</code>. These operators have no matrix representation, since if there was, it would be a linear operator instead of an affine operator. You can only represent an affine operator as a linear operator in a dimension of one larger via the operation: <code>[A b] * [u;1]</code>, so it would require something modified to the input as well. As such, affine operators are a distinct generalization of linear operators.</p><p>While it seems like it might doom the idea of using matrix-free affine operators, it turns out that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy generalization of the standard convergence proofs. If Q is the affine operator <span>$Q(x) = Ax + b$</span>, then solving <span>$Qx = c$</span> is equivalent to solving <span>$Ax + b = c$</span> or <span>$Ax = c-b$</span>. If you now do this same “plug-and-chug” handling of the affine operator into the GMRES/CG/etc. convergence proofs, move the affine part to the rhs residual, and show it converges to solving <span>$Ax = c-b$</span>, and thus GMRES/CG/etc. solves <span>$Q(x) = c$</span> for an affine operator properly.</p><p>That same trick can be used mostly anywhere you would&#39;ve had a linear operator to extend the proof to affine operators, so then <span>$exp(A*t)*v$</span> operations via Krylov methods work for A being affine as well, and all sorts of things. Thus, affine operators have no matrix representation, but they are still compatible with essentially any Krylov method, which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.</p><h2 id="Note-about-keyword-arguments-to-update_coefficients!"><a class="docs-heading-anchor" href="#Note-about-keyword-arguments-to-update_coefficients!">Note about keyword arguments to <code>update_coefficients!</code></a><a id="Note-about-keyword-arguments-to-update_coefficients!-1"></a><a class="docs-heading-anchor-permalink" href="#Note-about-keyword-arguments-to-update_coefficients!" title="Permalink"></a></h2><p>In rare cases, an operator may be used in a context where additional state is expected to be provided to <code>update_coefficients!</code> beyond <code>u</code>, <code>p</code>, and <code>t</code>. In this case, the operator may accept this additional state through arbitrary keyword arguments to <code>update_coefficients!</code>. When the caller provides these, they will be recursively propagated downwards through composed operators just like <code>u</code>, <code>p</code>, and <code>t</code>, and provided to the operator. For the <a href="../premade_operators/">premade SciMLOperators</a>, one can specify the keyword arguments used by an operator with an <code>accepted_kwargs</code> argument (by default, none are passed).</p><p>In the below example, we create an operator that gleefully ignores <code>u</code>, <code>p</code>, and <code>t</code> and uses its own special scaling.</p><pre><code class="language-julia hljs">using SciMLOperators

γ = ScalarOperator(0.0;
    update_func = (a, u, p, t; my_special_scaling) -&gt; my_special_scaling,
    accepted_kwargs = (:my_special_scaling,))

# Update coefficients, then apply operator
update_coefficients!(γ, nothing, nothing, nothing; my_special_scaling = 7.0)
@show γ * [2.0]

# Use operator application form
@show γ([2.0], nothing, nothing, nothing; my_special_scaling = 5.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">γ * [2.0] = [14.0]
γ([2.0], nothing, nothing, nothing; my_special_scaling = 5.0) = [10.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/fftw/">« FFT Tutorial</a><a class="docs-footer-nextpage" href="../premade_operators/">Premade Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 2 September 2025 03:44">Tuesday 2 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
