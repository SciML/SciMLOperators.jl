var documenterSearchIndex = {"docs":
[{"location":"interface/#operator_interface","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"","category":"section"},{"location":"interface/#SciMLOperators.AbstractSciMLOperator","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.AbstractSciMLOperator","text":"abstract type AbstractSciMLOperator{T}\n\nSubtypes of AbstractSciMLOperator represent linear, nonlinear, time-dependent operators acting on vectors, or matrix column-vectors. A lazy operator algebra is also defined for AbstractSciMLOperators.\n\nMathematical Notation\n\nAn AbstractSciMLOperator L is an operator which is used to represent the following type of equation:\n\nw = L(upt)v\n\nwhere L[v] is the operator application of L on the vector v.\n\nInterface\n\nAn AbstractSciMLOperator can be called  like a function in the following ways:\n\nL(v, u, p, t) - Out-of-place application where v is the action vector and u is the update vector\nL(w, v, u, p, t) - In-place application where w is the destination, v is the action vector, and u is the update vector\nL(w, v, u, p, t, α, β) - In-place application with scaling: w = α*(L*v) + β*w\n\nOperator state can be updated separately from application:\n\nupdate_coefficients!(L, u, p, t) for in-place operator update\nL = update_coefficients(L, u, p, t) for out-of-place operator update\n\nSciMLOperators also overloads Base.*, LinearAlgebra.mul!, LinearAlgebra.ldiv! for operator evaluation without updating operator state. An AbstractSciMLOperator behaves like a matrix in these methods. Allocation-free methods, suffixed with a ! often need cache arrays. To precache an AbstractSciMLOperator, call the function L = cache_operator(L, input_vector).\n\nOverloaded Actions\n\nThe behavior of a SciMLOperator is indistinguishable from an AbstractMatrix. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the AbstractMatrix interface includes, but is not limited to, the following:\n\nBase: size, zero, one, +, -, *, /, \\, ∘, inv, adjoint, transpose, convert\nLinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef\nSparseArrays: sparse, issparse\n\nMultidimensional arrays and batching\n\nSciMLOperator can also be applied to AbstractMatrix subtypes where operator-evaluation is done column-wise.\n\nK = 10\nu_mat = rand(N, K)\n\nv_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)\nsize(v_mat) == (N, K) # true\n\nL can also be applied to AbstractArrays that are not AbstractVecOrMats so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, SciMLOperators reshapes an N-dimensional array to an AbstractMatrix, and applies the operator via matrix-multiplication.\n\nOperator update\n\nThis package can also be used to write state-dependent, time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, Zygote-compatible way.\n\nFor example,\n\nu = rand(N)\np = rand(N)\nt = rand()\n\n# out-of-place update\nmat_update_func = (A, u, p, t) -> t * (p * u')\nsca_update_func = (a, u, p, t) -> t * sum(p)\n\nM = MatrixOperator(zero(N, N); update_func = mat_update_func)\nα = ScalarOperator(zero(Float64); update_func = sca_update_func)\n\nL = α * M\nL = cache_operator(L, v)\n\n# L is initialized with zero state\nL * v == zeros(N) # true\n\n# update operator state with `(u, p, t)`\nL = update_coefficients(L, u, p, t)\n# and multiply\nL * v != zeros(N) # true\n\n# updates state and evaluates L*v at (u, p, t)\nL(v, u, p, t) != zeros(N) # true\n\nThe out-of-place evaluation function L(v, u, p, t) calls update_coefficients under the hood, which recursively calls the update_func for each component SciMLOperator. Therefore, the out-of-place evaluation function is equivalent to calling update_coefficients followed by Base.*. Notice that the out-of-place evaluation does not return the updated operator.\n\nOn the other hand, the in-place evaluation function, L(w, v, u, p, t), mutates L, and is equivalent to calling update_coefficients! followed by mul!. The in-place update behavior works the same way, with a few <!>s appended here and there. For example,\n\nw = rand(N)\nv = rand(N)\nu = rand(N)\np = rand(N)\nt = rand()\n\n# in-place update\n_A = rand(N, N)\n_d = rand(N)\nmat_update_func! = (A, u, p, t) -> (copy!(A, _A); lmul!(t, A); nothing)\ndiag_update_func! = (diag, u, p, t) -> copy!(diag, N)\n\nM = MatrixOperator(zero(N, N); update_func! = mat_update_func!)\nD = DiagonalOperator(zero(N); update_func! = diag_update_func!)\n\nL = D * M\nL = cache_operator(L, v)\n\n# L is initialized with zero state\nL * v == zeros(N) # true\n\n# update L in-place\nupdate_coefficients!(L, v, p, t)\n# and multiply\nmul!(w, v, u, p, t) != zero(N) # true\n\n# updates L in-place, and evaluates w=L*v at (u, p, t)\nL(w, v, u, p, t) != zero(N) # true\n\nThe update behavior makes this package flexible enough to be used in OrdinaryDiffEq. As the parameter object p is often reserved for sensitivity computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow update functions with arbitrary keyword arguments.\n\nmat_update_func = (A, u, p, t; scale = 0.0) -> scale * (p * u')\n\nM = MatrixOperator(zero(N, N); update_func = mat_update_func,\n    accepted_kwargs = (:state,))\n\nM(v, u, p, t) == zeros(N) # true\nM(v, u, p, t; scale = 1.0) != zero(N)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Interface-API-Reference","page":"The AbstractSciMLOperator Interface","title":"Interface API Reference","text":"","category":"section"},{"location":"interface/#SciMLOperators.update_coefficients","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.update_coefficients","text":"update_coefficients(L, u, p, t; kwargs...)\n\n\nUpdate the state of L based on u, input vector, p parameter object, t, and keyword arguments. Internally, update_coefficients calls the user-provided update_func method for every component operator in L with the positional arguments (u, p, t) and keyword arguments corresponding to the symbols provided to the operator via kwarg accepted_kwargs.\n\nThis method is out-of-place, i.e. fully non-mutating and Zygote-compatible.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\nusing SciMLOperators\n\nmat_update_func = (A, u, p, t; scale = 1.0) -> p * p' * scale * t\n\nM = MatrixOperator(zeros(4,4); update_func = mat_update_func,\n                   accepted_kwargs = (:state,))\n\nL = M + IdentityOperator(4)\n\nu = rand(4)\np = rand(4)\nt = 1.0\n\n# Update the operator to `(u,p,t)` and apply it to `v`\nL = update_coefficients(L, u, p, t; scale = 2.0)\nresult = L * v\n\n# Or use the interface which separrates the update from the application\nresult = L(v, u, p, t; scale = 2.0)\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.update_coefficients!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.update_coefficients!","text":"update_coefficients!(L, u, p, t; kwargs...)\n\n\nUpdate in-place the state of L based on u, input vector, p parameter object, t, and keyword arguments. Internally, update_coefficients! calls the user-provided mutating update_func! method for every component operator in L with the positional arguments (u, p, t) and keyword arguments corresponding to the symbols provided to the operator via kwarg accepted_kwargs.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\nusing SciMLOperators\n\n_A = rand(4, 4)\nmat_update_func! = (L, u, p, t; scale = 1.0) -> copy!(A, _A)\n\nM = MatrixOperator(zeros(4,4); update_func! = mat_update_func!)\n\nL = M + IdentityOperator(4)\n\nu = rand(4)\np = rand(4)\nt = 1.0\n\nupdate_coefficients!(L, u, p, t)\nL * v\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.cache_operator","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.cache_operator","text":"cache_operator(L, u)\n\n\nAllocate caches for L for in-place evaluation with u-like input vectors.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.concretize","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.concretize","text":"concretize(L) -> AbstractMatrix\n\nconcretize(L) -> Number\n\nConvert SciMLOperator to a concrete type via eager fusion. This method is a no-op for types that are already concrete.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Traits","page":"The AbstractSciMLOperator Interface","title":"Traits","text":"","category":"section"},{"location":"interface/#SciMLOperators.isconstant","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.isconstant","text":"isconstant(_)\n\n\nChecks if an L's state is constant or needs to be updated by calling update_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.iscached","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.iscached","text":"iscached(L)\n\n\nChecks whether L has preallocated caches for inplace evaluations.\n\n\n\n\n\nCheck if SciMLOperator L has preallocated cache-arrays for in-place computation.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.issquare","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.issquare","text":"Checks if size(L, 1) == size(L, 2).\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.islinear","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.islinear","text":"islinear(_)\n\n\nChecks if L is a linear operator.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.isconvertible","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.isconvertible","text":"isconvertible(L) -> Bool\n\nChecks if L can be cheaply converted to an AbstractMatrix via eager fusion.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_adjoint","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_adjoint","text":"has_adjoint(L)\n\n\nCheck if adjoint(L) is lazily defined.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_expmv","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_expmv","text":"has_expmv(L)\n\n\nCheck if expmv(L, v, t), equivalent to exp(t * A) * v, is defined for Number t, and AbstractArray u of appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_expmv!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_expmv!","text":"has_expmv!(L)\n\n\nCheck if expmv!(w, L, v, t), equivalent to mul!(w, exp(t * A), v), is defined for Number t, and AbstractArrays w, v of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_exp","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_exp","text":"has_exp(L)\n\n\nCheck if exp(L) is defined lazily defined.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_mul","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_mul","text":"has_mul(L)\n\n\nCheck if L * v is defined for AbstractArray u of appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_mul!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_mul!","text":"has_mul!(L)\n\n\nCheck if mul!(w, L, v) is defined for AbstractArrays w, v of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_ldiv","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_ldiv","text":"has_ldiv(L)\n\n\nCheck if L \\ v is defined for AbstractArray v of appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_ldiv!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_ldiv!","text":"has_ldiv!(L)\n\n\nCheck if ldiv!(w, L, v) is defined for AbstractArrays w, v of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Note-About-Affine-Operators","page":"The AbstractSciMLOperator Interface","title":"Note About Affine Operators","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"Affine operators are operators that have the action Q*x = A*x + b. These operators have no matrix representation, since if there was, it would be a linear operator instead of an affine operator. You can only represent an affine operator as a linear operator in a dimension of one larger via the operation: [A b] * [u;1], so it would require something modified to the input as well. As such, affine operators are a distinct generalization of linear operators.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"While it seems like it might doom the idea of using matrix-free affine operators, it turns out that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy generalization of the standard convergence proofs. If Q is the affine operator Q(x) = Ax + b, then solving Qx = c is equivalent to solving Ax + b = c or Ax = c-b. If you now do this same “plug-and-chug” handling of the affine operator into the GMRES/CG/etc. convergence proofs, move the affine part to the rhs residual, and show it converges to solving Ax = c-b, and thus GMRES/CG/etc. solves Q(x) = c for an affine operator properly.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"That same trick can be used mostly anywhere you would've had a linear operator to extend the proof to affine operators, so then exp(A*t)*v operations via Krylov methods work for A being affine as well, and all sorts of things. Thus, affine operators have no matrix representation, but they are still compatible with essentially any Krylov method, which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.","category":"page"},{"location":"interface/#Note-about-keyword-arguments-to-update_coefficients!","page":"The AbstractSciMLOperator Interface","title":"Note about keyword arguments to update_coefficients!","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"In rare cases, an operator may be used in a context where additional state is expected to be provided to update_coefficients! beyond u, p, and t. In this case, the operator may accept this additional state through arbitrary keyword arguments to update_coefficients!. When the caller provides these, they will be recursively propagated downwards through composed operators just like u, p, and t, and provided to the operator. For the premade SciMLOperators, one can specify the keyword arguments used by an operator with an accepted_kwargs argument (by default, none are passed).","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"In the below example, we create an operator that gleefully ignores u, p, and t and uses its own special scaling.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"using SciMLOperators\n\nγ = ScalarOperator(0.0;\n    update_func = (a, u, p, t; my_special_scaling) -> my_special_scaling,\n    accepted_kwargs = (:my_special_scaling,))\n\n# Update coefficients, then apply operator\nupdate_coefficients!(γ, nothing, nothing, nothing; my_special_scaling = 7.0)\n@show γ * [2.0]\n\n# Use operator application form\n@show γ([2.0], nothing, nothing, nothing; my_special_scaling = 5.0)\nnothing # hide","category":"page"},{"location":"premade_operators/#premade_operators","page":"Premade Operators","title":"Premade SciMLOperators","text":"","category":"section"},{"location":"premade_operators/#Direct-Operator-Definitions","page":"Premade Operators","title":"Direct Operator Definitions","text":"","category":"section"},{"location":"premade_operators/#SciMLOperators.IdentityOperator","page":"Premade Operators","title":"SciMLOperators.IdentityOperator","text":"struct IdentityOperator <: SciMLOperators.AbstractSciMLOperator{Bool}\n\nOperator representing the identity function id(v) = v\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.NullOperator","page":"Premade Operators","title":"SciMLOperators.NullOperator","text":"struct NullOperator <: SciMLOperators.AbstractSciMLOperator{Bool}\n\nOperator representing the null function n(v) = 0 * v\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.ScalarOperator","page":"Premade Operators","title":"SciMLOperators.ScalarOperator","text":"ScalarOperator(val; update_func, accepted_kwargs)\n\n\nRepresents a linear scaling operator that may be applied to a Number, or an AbstractArray subtype. Its state is updated by the user-provided update_func during operator evaluation (L([w,] v, u, p, t)), or by calls to update_coefficients[!]. Both recursively call the update function, update_func which is assumed to have the signature:\n\nupdate_func(oldval::Number, u, p, t; <accepted kwargs>) -> newval\n\nThe set of keyword-arguments accepted by update_func must be provided to ScalarOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy scalar algebra is defined for AbstractSciMLScalarOperators. The interface supports lazy addition, subtraction, multiplication and division.\n\nExample\n\nv = rand(4)\nu = rand(4)\nw = zeros(4)\np = nothing\nt = 0.0\n\nval_update = (a, u, p, t; scale = 0.0) -> scale\nα = ScalarOperator(0.0; update_func = val_update, accepted_kwargs = (:scale,))\nβ = 2 * α + 3 / α\n\n# Update β and evaluate with the new interface\nresult = β(v, u, p, t; scale = 1.0)\n\n# In-place application\nβ(w, v, u, p, t; scale = 1.0)\n\n# In-place with scaling\nw_orig = copy(w)\nα_val = 2.0\nβ_val = 0.5\nβ(w, v, u, p, t, α_val, β_val; scale = 1.0) # w = α_val*(β*v) + β_val*w\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.MatrixOperator","page":"Premade Operators","title":"SciMLOperators.MatrixOperator","text":"Represents a linear operator given by an AbstractMatrix that may be applied to an AbstractVecOrMat. Its state is updated by the user-provided update_func during operator evaluation (L([w,], v, u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(A::AbstractMatrix, u, p, t; <accepted kwargs>) -> newA\n\nor\n\nupdate_func!(A::AbstractMatrix, u, p, t; <accepted kwargs>) -> [modifies A]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy matrix algebra is defined for AbstractSciMLOperators. The Interface supports lazy addition, subtraction, multiplication, inversion, adjoints, transposes.\n\nExample\n\nOut-of-place update and usage\n\nv = rand(4)\nu = rand(4)\np = rand(4, 4)\nt = rand()\n\nmat_update = (A, u, p, t; scale = 0.0) -> t * p\nM = MatrixOperator(0.0; update_func = mat_update, accepted_kwargs = (:scale,))\n\nL = M * M + 3I\nL = cache_operator(L, v)\n\n# update and evaluate \nw = L(v, u, p, t; scale = 1.0)\n\n# In-place evaluation\nw = similar(v)\nL(w, v, u, p, t; scale = 1.0)\n\n# In-place with scaling\nβ = 0.5\nL(w, v, u, p, t, 2.0, β; scale = 1.0) # w = 2.0*(L*v) + 0.5*w\n\nIn-place update and usage\n\nw = zeros(4)\nv = zeros(4)\nu = rand(4)\np = rand(4) # Must be non-nothing\nt = rand()\n\nmat_update! = (A, u, p, t; scale = 0.0) -> (A .= t * p * u' * scale)\nM = MatrixOperator(zeros(4, 4); update_func! = mat_update!, accepted_kwargs = (:scale,))\nL = M * M + 3I\nL = cache_operator(L, v) \n\n# update L in-place and evaluate\nupdate_coefficients!(L, u, p, t; scale = 1.0)\nmul!(w, L, v)\n\n# Or use the new interface that separates update and application\nL(w, v, u, p, t; scale = 1.0)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.DiagonalOperator","page":"Premade Operators","title":"SciMLOperators.DiagonalOperator","text":"DiagonalOperator(\n    diag;\n    update_func,\n    update_func!,\n    accepted_kwargs\n)\n\n\nRepresents an elementwise scaling (diagonal-scaling) operation that may be applied to an AbstractVecOrMat. When diag is an AbstractVector of length N, L = DiagonalOperator(diag, ...) can be applied to AbstractArrays with size(u, 1) == N. Each column of the v will be scaled by diag, as in LinearAlgebra.Diagonal(diag) * v.\n\nWhen diag is a multidimensional array, L = DiagonalOperator(diag, ...) forms an operator of size (N, N) where N = size(diag, 1) is the leading length of diag. L then is the elementwise-scaling operation on arrays of length(v) = length(diag) with leading length size(u, 1) = N.\n\nIts state is updated by the user-provided update_func during operator evaluation (L([w,], v, u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> new_diag\n\nor\n\nupdate_func!(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> [modifies diag]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\n\n\n\n\n","category":"function"},{"location":"premade_operators/#SciMLOperators.AffineOperator","page":"Premade Operators","title":"SciMLOperators.AffineOperator","text":"Represents a generalized affine operation (w = A * v + B * b) that may be applied to an AbstractVecOrMat. The user-provided update functions, update_func[!] update the AbstractVecOrMat b, and are called during operator evaluation (L([w,], v, u, p, t)), or by calls to update_coefficients[!](L, u, p, t). The update functions are assumed to have the syntax\n\nupdate_func(b::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> new_b\n\nor\n\nupdate_func!(b::AbstractVecOrMat, u ,p , t; <accepted kwargs>) -> [modifies b]\n\nand B, b are expected to have an appropriate size so that A * v + B * b makes sense. Specifically, size(A, 1) == size(B, 1), and size(v, 2) == size(b, 2).\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to AffineOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nExample\n\nv = rand(4)\nu = rand(4)\np = rand(4)\nt = rand()\n\nA = MatrixOperator(rand(4, 4))\nB = MatrixOperator(rand(4, 4))\n\nvec_update_func = (b, u, p, t) -> p .* u * t\nL = AffineOperator(A, B, zeros(4); update_func = vec_update_func)\nL = cache_operator(M, v)\n\n# update L and evaluate\nw = L(v, u, p, t) # == A * v + B * (p .* u * t)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.AddVector","page":"Premade Operators","title":"SciMLOperators.AddVector","text":"AddVector(b; update_func, update_func!, accepted_kwargs)\n\n\nRepresents the affine operation w = I * v + I * b. The update functions, update_func[!] update the state of AbstractVecOrMat b. See documentation of AffineOperator for more details.\n\n\n\n\n\nAddVector(B, b; update_func, update_func!, accepted_kwargs)\n\n\nRepresents the affine operation w = I * v + B * b. The update functions, update_func[!] update the state of AbstractVecOrMat b. See documentation of AffineOperator for more details.\n\n\n\n\n\n","category":"function"},{"location":"premade_operators/#SciMLOperators.FunctionOperator","page":"Premade Operators","title":"SciMLOperators.FunctionOperator","text":"Matrix free operator given by a function\n\nop:  Function with signature op(v, u, p, t) and (if isinplace) op(w, v, u, p, t)\nop_adjoint:  Adjoint operator\nop_inverse:  Inverse operator\nop_adjoint_inverse:  Adjoint inverse operator\ntraits:  Traits\nu:  State\np:  Parameters\nt:  Time\ncache:  Cache\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.TensorProductOperator","page":"Premade Operators","title":"SciMLOperators.TensorProductOperator","text":"Computes the lazy pairwise Kronecker product, or tensor product, operator of AbstractMatrix, and AbstractSciMLOperator subtypes. Calling ⊗(ops...) is equivalent to Base.kron(ops...). Fast operator evaluation is performed without forming the full tensor product operator.\n\nTensorProductOperator(A, B) = A ⊗ B\nTensorProductOperator(A, B, C) = A ⊗ B ⊗ C\n\n(A ⊗ B)(v) = vec(B * reshape(v, M, N) * transpose(A))\n\nwhere M = size(B, 2), and N = size(A, 2)\n\nExample\n\nusing SciMLOperators, LinearAlgebra\n\n# Create basic operators\nA = rand(3, 3)\nB = rand(4, 4)\nA_op = MatrixOperator(A)\nB_op = MatrixOperator(B)\n\n# Create tensor product operator\nT = A_op ⊗ B_op\n\n# Apply to a vector using the new interface\nv = rand(3*4)    # Action vector\nu = rand(3*4)    # Update vector\np = nothing\nt = 0.0\n\n# Out-of-place application\nresult = T(v, u, p, t)\n\n# For in-place operations, need to cache the operator first\nT_cached = cache_operator(T, v)\n\n# In-place application\nw = zeros(size(T, 1))\nT_cached(w, v, u, p, t)\n\n# In-place with scaling\nw_orig = copy(w)\nα = 2.0\nβ = 0.5\nT_cached(w, v, u, p, t, α, β) # w = α*(T*v) + β*w_orig\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#Lazy-Scalar-Operator-Combination","page":"Premade Operators","title":"Lazy Scalar Operator Combination","text":"","category":"section"},{"location":"premade_operators/#SciMLOperators.AddedScalarOperator","page":"Premade Operators","title":"SciMLOperators.AddedScalarOperator","text":"struct AddedScalarOperator{T, O} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy addition of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.ComposedScalarOperator","page":"Premade Operators","title":"SciMLOperators.ComposedScalarOperator","text":"struct ComposedScalarOperator{T, O} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy multiplication of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.InvertedScalarOperator","page":"Premade Operators","title":"SciMLOperators.InvertedScalarOperator","text":"struct InvertedScalarOperator{T, λType} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy inverse of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#Lazy-Operator-Combination","page":"Premade Operators","title":"Lazy Operator Combination","text":"","category":"section"},{"location":"premade_operators/#SciMLOperators.ScaledOperator","page":"Premade Operators","title":"SciMLOperators.ScaledOperator","text":"struct ScaledOperator{T, λType, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\nScaledOperator\n\n(λ L)*(v) = λ * L(v)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.AddedOperator","page":"Premade Operators","title":"SciMLOperators.AddedOperator","text":"Lazy operator addition\n\n(A1 + A2 + A3...)v = A1*v + A2*v + A3*v ....\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.ComposedOperator","page":"Premade Operators","title":"SciMLOperators.ComposedOperator","text":"Lazy operator composition\n\n∘(A, B, C)(v) = A(B(C(v)))\n\nops = (A, B, C)\ncache = (B*C*v , C*v)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.InvertedOperator","page":"Premade Operators","title":"SciMLOperators.InvertedOperator","text":"Lazy Operator Inverse\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.InvertibleOperator","page":"Premade Operators","title":"SciMLOperators.InvertibleOperator","text":"Stores an operator and its factorization (or inverse operator). Supports left division and ldiv! via F, and operator evaluation via L.\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.AdjointOperator","page":"Premade Operators","title":"SciMLOperators.AdjointOperator","text":"struct AdjointOperator{T, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.TransposedOperator","page":"Premade Operators","title":"SciMLOperators.TransposedOperator","text":"struct TransposedOperator{T, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\n\n\n\n\n","category":"type"},{"location":"tutorials/operator_algebras/#operator_algebras","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"","category":"section"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"Let M, D, F be matrix-based, diagonal-matrix-based, and function-based SciMLOperators respectively. Here are some examples of composing operators in order to build more complex objects and using their operations.","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"using SciMLOperators, LinearAlgebra\nN = 4\nfunction f(v, u, p, t)\n    u .* v\nend\nfunction f(w, v, u, p, t)\n    w .= u .* v\nend\n\nu = rand(4)\np = nothing # parameter struct\nt = 0.0     # time\n\nM = MatrixOperator(rand(N, N))\nD = DiagonalOperator(rand(N))\nF = FunctionOperator(f, zeros(N), zeros(N); u, p, t)","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"Then, the following codes just work.","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"L1 = 2M + 3F + LinearAlgebra.I + rand(N, N)\nL2 = D * F * M'\nL3 = kron(M, D, F)\nL4 = lu(M) \\ D\nL5 = [M; D]' * [M F; F D] * [F; D]","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"Each L# can be applied to AbstractVectors of appropriate sizes:","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"v = rand(N)\nw = L1(v, u, p, t) # == L1 * v\n\nv_kron = rand(N^3)\nw_kron = L3(v_kron, u, p, t) # == L3 * v_kron","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"For mutating operator evaluations, call cache_operator to generate an in-place cache, so the operation is nonallocating.","category":"page"},{"location":"tutorials/operator_algebras/","page":"Demonstration of Operator Algebras and Kron","title":"Demonstration of Operator Algebras and Kron","text":"α, β = rand(2)\n\n# allocate cache\nL2 = cache_operator(L2, u)\nL4 = cache_operator(L4, u)\n\n# allocation-free evaluation\nL2(w, v, u, p, t) # == mul!(w, L2, v)\nL4(w, v, u, p, t, α, β) # == mul!(w, L4, v, α, β)","category":"page"},{"location":"tutorials/fftw/#fft","page":"FFT Tutorial","title":"Wrap a Fourier transform with SciMLOperators","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"In this tutorial, we will wrap a Fast Fourier Transform (FFT) in a SciMLOperator via the FunctionOperator interface. FFTs are commonly used algorithms for performing numerical interpolation and differentiation. In this example, we will use the FFT to compute the derivative of a function.","category":"page"},{"location":"tutorials/fftw/#Copy-Paste-Code","page":"FFT Tutorial","title":"Copy-Paste Code","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"using SciMLOperators\nusing LinearAlgebra, FFTW\n\nn = 256\nL = 2π\n\ndx = L / n\nx = range(start = -L / 2, stop = L / 2 - dx, length = n) |> Array\nv = @. sin(5x)cos(7x);\nw = @. 5cos(5x)cos(7x) - 7sin(5x)sin(7x);\n\nk = rfftfreq(n, 2π * n / L) |> Array\nm = length(k)\nP = plan_rfft(x)\n\nfwd(v, u, p, t) = P * v\nbwd(v, u, p, t) = P \\ v\n\nfwd(w, v, u, p, t) = mul!(w, P, v)\nbwd(w, v, u, p, t) = ldiv!(w, P, v)\n\nF = FunctionOperator(fwd, x, im * k;\n    T = ComplexF64, op_adjoint = bwd,\n    op_inverse = bwd,\n    op_adjoint_inverse = fwd, islinear = true\n)\n\nik = im * DiagonalOperator(k)\nDx = F \\ ik * F\n\nDx = cache_operator(Dx, v)\n\n@show ≈(Dx * v, w; atol = 1e-8)\n@show ≈(mul!(copy(w), Dx, v), w; atol = 1e-8)","category":"page"},{"location":"tutorials/fftw/#Explanation","page":"FFT Tutorial","title":"Explanation","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"We load SciMLOperators, LinearAlgebra, and FFTW (short for Fastest Fourier Transform in the West), a common Fourier transform library. Next, we define an equispaced grid from -π to π, and write the function u that we intend to differentiate. Since this is a trivial example, we already know the derivative, du, and write it down to later test our FFT wrapper.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"using SciMLOperators\nusing LinearAlgebra, FFTW\n\nL = 2π\nn = 256\ndx = L / n\nx = range(start = -L / 2, stop = L / 2 - dx, length = n) |> Array\n\nv = @. sin(5x)cos(7x);\nw = @. 5cos(5x)cos(7x) - 7sin(5x)sin(7x);","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"Now, we define the Fourier transform. Since our input is purely Real, we use the real Fast Fourier Transform. The function plan_rfft outputs a real fast Fourier transform object that can be applied to inputs that are like x as follows: xhat = transform * x, and LinearAlgebra.mul!(xhat, transform, x).  We also get k, the frequency modes sampled by our finite grid, via the function rfftfreq.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"k = rfftfreq(n, 2π * n / L) |> Array\nm = length(k)\nP = plan_rfft(x)","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"Now we are ready to define our wrapper for the FFT object. To FunctionOperator, we pass the in-place forward application of the transform, (w,v,u,p,t) -> mul!(w, transform, v), its inverse application, (w,v,u,p,t) -> ldiv!(w, transform, v), as well as input and output prototype vectors.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"fwd(v, u, p, t) = P * v\nbwd(v, u, p, t) = P \\ v\n\nfwd(w, v, u, p, t) = mul!(w, P, v)\nbwd(w, v, u, p, t) = ldiv!(w, P, v)\nF = FunctionOperator(fwd, x, im * k;\n    T = ComplexF64, op_adjoint = bwd,\n    op_inverse = bwd,\n    op_adjoint_inverse = fwd, islinear = true\n)","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"After wrapping the FFT with FunctionOperator, we are ready to compose it with other SciMLOperators. Below, we form the derivative operator, and cache it via the function cache_operator that requires an input prototype. We can test our derivative operator both in-place, and out-of-place by comparing its output to the analytical derivative.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"ik = im * DiagonalOperator(k)\nDx = F \\ ik * F\n\nDx = cache_operator(Dx, x)\n\n@show ≈(Dx * v, w; atol = 1e-8)\n@show ≈(mul!(copy(w), Dx, v), w; atol = 1e-8)","category":"page"},{"location":"tutorials/getting_started/#Getting-Started-with-Matrix-Free-Operators-in-Julia","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"SciMLOperators.jl is a package for defining operators for use in solvers. One of the major use cases is to define matrix-free operators in cases where using a matrix would be too memory expensive. In this tutorial we will walk through the main features of SciMLOperators and get you going with matrix-free and updating operators.","category":"page"},{"location":"tutorials/getting_started/#Simplest-Operator:-MatrixOperator","page":"Getting Started with Matrix-Free Operators in Julia","title":"Simplest Operator: MatrixOperator","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Before we get into the deeper operators, let's show the simplest SciMLOperator: MatrixOperator. MatrixOperator just turns a matrix into an AbstractSciMLOperator, so it's not really a matrix-free operator but it's a starting point that is good for understanding the interface and testing. To create a MatrixOperator, simply call the constructor on a matrix:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"using SciMLOperators, LinearAlgebra\nA = [-2.0 1 0 0 0\n     1 -2 1 0 0\n     0 1 -2 1 0\n     0 0 1 -2 1\n     0 0 0 1 -2]\n\nopA = MatrixOperator(A)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"The operators can do operations as defined in the operator interface, for example, matrix multiplication as the core action:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"v = [3.0, 2.0, 1.0, 2.0, 3.0]\nopA*v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"opA(v, nothing, nothing, nothing) # Call = opA*v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"w = zeros(5)\nmul!(w, opA, v)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"α = 1.0;\nβ = 1.0\nmul!(w, opA, v, α, β) # α*opA*v + β*w","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"and the inverse operation:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"opA \\ v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"ldiv!(w, lu(opA), v)","category":"page"},{"location":"tutorials/getting_started/#State,-Parameter,-and-Time-Dependent-Operators","page":"Getting Started with Matrix-Free Operators in Julia","title":"State, Parameter, and Time-Dependent Operators","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Now let's define a MatrixOperator the is dependent on state, parameters, and time. For example, let's make the operator A .* u + dt*I where dt is a parameter and u is a state vector:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"A = [-2.0 1 0 0 0\n     1 -2 1 0 0\n     0 1 -2 1 0\n     0 0 1 -2 1\n     0 0 0 1 -2]\n\nfunction update_function!(B, u, p, t)\n    dt = p\n    B .= A .* u + dt*I\nend\n\nu = Array(1:1.0:5);\np = 0.1;\nt = 0.0\nopB = MatrixOperator(copy(A); update_func! = update_function!)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"To update the operator, you would use update_coefficients!(opB, u, p, t):","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"update_coefficients!(opB, u, p, t)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"We can use the interface to see what the current matrix is by converting to a standard matrix:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"convert(AbstractMatrix, opB)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"And now applying the operator applies the updated one:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"opB*v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Or if you use the operator application, it will update and apply in one step:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"opB(v, Array(2:1.0:6), 0.5, nothing) # opB(u,p,t)*v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"This is how for example, when an ODE solver asks for an operator L(u,p,t)*u, this is how such an operator can be defined. Notice that the interface can be queried to understand the traits of the operator, such as for example whether an operator is constant (does not change w.r.t. (u,p,t)):","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"isconstant(opA)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"isconstant(opB)","category":"page"},{"location":"tutorials/getting_started/#Matrix-Free-Operators-via-FunctionOperator","page":"Getting Started with Matrix-Free Operators in Julia","title":"Matrix-Free Operators via FunctionOperator","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Now let's define the operators from above in a matrix-free way using FunctionOperator. With FunctionOperator, we directly define the operator application function opA(w,v,u,p,t) which means w = opA(u,p,t)*v. For example we can do the following:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"function Afunc!(w, v, u, p, t)\n    w[1] = -2v[1] + v[2]\n    for i in 2:4\n        w[i] = v[i - 1] - 2v[i] + v[i + 1]\n    end\n    w[5] = v[4] - 2v[5]\n    nothing\nend\n\nfunction Afunc!(v, u, p, t)\n    w = zeros(5)\n    Afunc!(w, v, u, p, t)\n    w\nend\n\nmfopA = FunctionOperator(Afunc!, zeros(5), zeros(5))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Now mfopA acts just like A*v and thus opA:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"mfopA*v - opA*v","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"mfopA(v, u, p, t) - opA(v, u, p, t)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"We can also create the state-dependent operator as well:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"function Bfunc!(w, v, u, p, t)\n    dt = p\n    w[1] = -(2*u[1]-dt)*v[1] + v[2]*u[1]\n    for i in 2:4\n        w[i] = v[i - 1]*u[i] - (2*u[i]-dt)*v[i] + v[i + 1]*u[i]\n    end\n    w[5] = v[4]*u[5] - (2*u[5]-dt)*v[5]\n    nothing\nend\n\nfunction Bfunc!(v, u, p, t)\n    w = zeros(5)\n    Bfunc!(w, v, u, p, t)\n    w\nend\n\nmfopB = FunctionOperator(Bfunc!, zeros(5), zeros(5); u, p, t, isconstant = false)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"opB(v, Array(2:1.0:6), 0.5, nothing) - mfopB(v, Array(2:1.0:6), 0.5, nothing)","category":"page"},{"location":"tutorials/getting_started/#Operator-Algebras","page":"Getting Started with Matrix-Free Operators in Julia","title":"Operator Algebras","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"While the operators are lazy operations and thus are not full matrices, you can still do algebra on operators. This will construct a new lazy operator that will be able to compute the same action as the composed function. For example, let's create mfopB using mfopA. Recall that we defined this via A .* u + dt*I. Let's first create an operator for A .* u (since right now there is not a built in operator for vector scaling, but that would be a fantastic thing to add!):","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"function Cfunc!(w, v, u, p, t)\n    w[1] = -2v[1] + v[2]\n    for i in 2:4\n        w[i] = v[i - 1] - 2v[i] + v[i + 1]\n    end\n    w[5] = v[4] - 2v[5]\n    w .= w .* u\n    nothing\nend\n\nfunction Cfunc!(v, u, p, t)\n    w = zeros(5)\n    Cfunc!(w, v, u, p, t)\n    w\nend\n\nmfopC = FunctionOperator(Cfunc!, zeros(5), zeros(5))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"And now let's create the operator mfopC + dt*I. We can just directly build it:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"mfopD = mfopC + 0.5*I","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"SciMLOperators.jl uses an IdentityOperator and ScalarOperator instead of the Base utilities, but the final composed operator acts just like the operator that was built:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"mfopB(v, Array(2:1.0:6), 0.5, nothing) - mfopD(v, Array(2:1.0:6), 0.5, nothing)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"There are many cool things you can do with operator algebras, such as kron (Kronecker products), adjoints, inverses, and more. For more information, see the operator algebras tutorial.","category":"page"},{"location":"tutorials/getting_started/#Where-to-go-next?","page":"Getting Started with Matrix-Free Operators in Julia","title":"Where to go next?","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Great! You now know how to be state/parameter/time-dependent operators and make them matrix-free, along with doing algebras on operators. What's next?","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Interested in more examples of building operators? See the example of making a fast fourier transform linear operator\nInterested in more operators ready to go? See the Premade Operators page for all of the operators included with SciMLOperators. Note that there are also downstream packages that make new operators.\nWant to make your own SciMLOperator? See the AbstractSciMLOperator interface page which describes the full interface.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"How do you use SciMLOperators? Check out the following downstream pages:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with Matrix-Free Operators in Julia","title":"Getting Started with Matrix-Free Operators in Julia","text":"Using SciMLOperators in LinearSolve.jl for matrix-free Krylov methods\nUsing SciMLOperators in OrdinaryDiffEq.jl for semi-linear ODE solvers","category":"page"},{"location":"#SciMLOperators.jl:-Unified-operator-interface-for-Julia-and-SciML","page":"Home","title":"SciMLOperators.jl: Unified operator interface for Julia and SciML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SciMLOperators is a package for managing linear, nonlinear, time-dependent, and parameter dependent operators acting on vectors, (or column-vectors of matrices). We provide wrappers for matrix-free operators, fast tensor-product evaluations, pre-cached mutating evaluations, as well as Zygote-compatible non-mutating evaluations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The lazily implemented operator algebra allows the user to update the operator state by passing in an update function that accepts arbitrary parameter objects. Further, our operators behave like AbstractMatrix types thanks to overloads defined for methods in Base, and LinearAlgebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, an AbstractSciMLOperator can be passed to LinearSolve.jl, or NonlinearSolve.jl as a linear or nonlinear operator, or to OrdinaryDiffEq.jl as an ODEFunction. Examples of usage within the SciML ecosystem are provided in the documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SciMLOperators.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SciMLOperators\")","category":"page"},{"location":"#Why-SciMLOperators?","page":"Home","title":"Why SciMLOperators?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Many functions, from linear solvers to differential equations, require the use of matrix-free operators to achieve maximum performance in many scenarios. SciMLOperators.jl defines the abstract interface for how operators in the SciML ecosystem are supposed to be defined. It gives the common set of functions and traits that solvers can rely on for properly performing their tasks. Along with that, SciMLOperators.jl provides definitions for the basic standard operators that are used as building blocks for most tasks, simplifying the use of operators while also demonstrating to users how such operators can be built and used in practice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SciMLOperators.jl has the design that is required to be used in all scenarios of equation solvers. For example, Magnus integrators for differential equations require defining an operator u = A(t) u, while Munthe-Kaas methods require defining operators of the form u = A(u) u. Thus, the operators need some form of time and state dependence, which the solvers can update and query when they are non-constant (update_coefficients!). Additionally, the operators need the ability to act like “normal” functions for equation solvers. For example, if A(v,u,p,t) has the same operation as update_coefficients(A, u, p, t); A * v, then A can be used in any place where a differential equation definition (u,p,t) -> A(u, u, p, t) is used without requiring the user or solver to do any extra work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another example is state-dependent mass matrices. M(u,p,t)*u' = f(u,p,t). When solving such an equation, the solver must understand how to \"update M\" during operations, and thus the ability to update the state of M is a required function in the interface. This is also required for the definition of Jacobians J(u,p,t) in order to be properly used with Krylov methods inside of ODE solves without reconstructing the matrix-free operator at each step.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus while previous good efforts for matrix-free operators have existed in the Julia ecosystem, such as LinearMaps.jl, those operator interfaces lack these aspects to actually be fully seamless with downstream equation solvers. This necessitates the definition and use of an extended operator interface with all of these properties, hence the AbstractSciMLOperator interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warn: Warn\nThis means that LinearMaps.jl is fundamentally lacking and is incompatible with many of the tools in the SciML ecosystem, except for the specific cases where the matrix-free operator is a constant!","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Matrix-free operators with FunctionOperator\nFast tensor product evaluation with TensorProductOperator\nLazy algebra: addition, subtraction, multiplication, inverse, adjoint, and transpose\nCouple fast methods for operator evaluation with inversion via InvertibleOperator\nOne-line API to update operator state depending on arbitrary parameters.\nMutating and nonmutating update behavior (Zygote compatible)\nOne-line API for pre-caching operators for in-place operator evaluations","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
