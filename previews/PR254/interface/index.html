<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The AbstractSciMLOperator Interface · SciMLOperators.jl</title><meta name="title" content="The AbstractSciMLOperator Interface · SciMLOperators.jl"/><meta property="og:title" content="The AbstractSciMLOperator Interface · SciMLOperators.jl"/><meta property="twitter:title" content="The AbstractSciMLOperator Interface · SciMLOperators.jl"/><meta name="description" content="Documentation for SciMLOperators.jl."/><meta property="og:description" content="Documentation for SciMLOperators.jl."/><meta property="twitter:description" content="Documentation for SciMLOperators.jl."/><meta property="og:url" content="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><meta property="twitter:url" content="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><link rel="canonical" href="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SciMLOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SciMLOperators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../sciml/">Usage with <code>SciML</code> and beyond</a></li><li class="is-active"><a class="tocitem" href>The <code>AbstractSciMLOperator</code> Interface</a><ul class="internal"><li><a class="tocitem" href="#Formal-Properties-of-SciMLOperators"><span>Formal Properties of SciMLOperators</span></a></li><li><a class="tocitem" href="#Overloaded-Traits"><span>Overloaded Traits</span></a></li><li><a class="tocitem" href="#Multidimensional-arrays-and-batching"><span>Multidimensional arrays and batching</span></a></li><li><a class="tocitem" href="#Operator-update"><span>Operator update</span></a></li><li><a class="tocitem" href="#Interface-API-Reference"><span>Interface API Reference</span></a></li><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#Note-About-Affine-Operators"><span>Note About Affine Operators</span></a></li><li><a class="tocitem" href="#Note-about-keyword-arguments-to-update_coefficients!"><span>Note about keyword arguments to <code>update_coefficients!</code></span></a></li></ul></li><li><a class="tocitem" href="../premade_operators/">Premade Operators</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/fftw/">FFT Tutorial</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The <code>AbstractSciMLOperator</code> Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The <code>AbstractSciMLOperator</code> Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLOperators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLOperators.jl/blob/master/docs/src/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-AbstractSciMLOperator-Interface"><a class="docs-heading-anchor" href="#The-AbstractSciMLOperator-Interface">The <code>AbstractSciMLOperator</code> Interface</a><a id="The-AbstractSciMLOperator-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractSciMLOperator-Interface" title="Permalink"></a></h1><h2 id="Formal-Properties-of-SciMLOperators"><a class="docs-heading-anchor" href="#Formal-Properties-of-SciMLOperators">Formal Properties of SciMLOperators</a><a id="Formal-Properties-of-SciMLOperators-1"></a><a class="docs-heading-anchor-permalink" href="#Formal-Properties-of-SciMLOperators" title="Permalink"></a></h2><p>These are the formal properties that an <code>AbstractSciMLOperator</code> should obey for it to work in the solvers.</p><ol><li>An <code>AbstractSciMLOperator</code> represents a linear or nonlinear operator, with input/output being <code>AbstractArray</code>s. Specifically, a SciMLOperator, <code>L</code>, of size <code>(M, N)</code> accepts an input argument <code>u</code> with leading length <code>N</code>, i.e. <code>size(u, 1) == N</code>, and returns an <code>AbstractArray</code> of the same dimension with leading length <code>M</code>, i.e. <code>size(L * u, 1) == M</code>.</li><li>SciMLOperators can be applied to an <code>AbstractArray</code> via overloaded <code>Base.*</code>, or the in-place <code>LinearAlgebra.mul!</code>. Additionally, operators are allowed to be time, or parameter dependent. The state of a SciMLOperator can be updated by calling the mutating function <code>update_coefficients!(L, u, p, t)</code> where <code>p</code> represents parameters, and <code>t</code>, time.  Calling a SciMLOperator as <code>L(du, u, p, t)</code> or out-of-place <code>L(u, p, t)</code> will automatically update the state of <code>L</code> before applying it to <code>u</code>. <code>L(u, p, t)</code> is the same operation as <code>L(u, p, t) * u</code>.</li><li>To support the update functionality, we have lazily implemented a comprehensive operator algebra. That means a user can add, subtract, scale, compose and invert SciMLOperators, and the state of the resultant operator would be updated as expected upon calling <code>L(du, u, p, t)</code> or <code>L(u, p, t)</code> so long as an update function is provided for the component operators.</li></ol><h2 id="Overloaded-Traits"><a class="docs-heading-anchor" href="#Overloaded-Traits">Overloaded Traits</a><a id="Overloaded-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Overloaded-Traits" title="Permalink"></a></h2><p>Thanks to overloads defined for evaluation methods and traits in <code>Base</code>, <code>LinearAlgebra</code>, the behavior of a <code>SciMLOperator</code> is indistinguishable from an <code>AbstractMatrix</code>. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the <code>AbstractMatrix</code> interface includes, but is not limited to, the following:</p><ul><li><code>Base: size, zero, one, +, -, *, /, \, ∘, inv, adjoint, transpose, convert</code></li><li><code>LinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef</code></li><li><code>SparseArrays: sparse, issparse</code></li></ul><h2 id="Multidimensional-arrays-and-batching"><a class="docs-heading-anchor" href="#Multidimensional-arrays-and-batching">Multidimensional arrays and batching</a><a id="Multidimensional-arrays-and-batching-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-arrays-and-batching" title="Permalink"></a></h2><p>SciMLOperator can also be applied to <code>AbstractMatrix</code> subtypes where operator-evaluation is done column-wise.</p><pre><code class="language-julia hljs">K = 10
u_mat = rand(N, K)

v_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)
size(v_mat) == (N, K) # true</code></pre><p><code>L#</code> can also be applied to <code>AbstractArray</code>s that are not <code>AbstractVecOrMat</code>s so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, <code>SciMLOperator</code>s reshapes an <code>N</code>-dimensional array to an <code>AbstractMatrix</code>, and applies the operator via matrix-multiplication.</p><h2 id="Operator-update"><a class="docs-heading-anchor" href="#Operator-update">Operator update</a><a id="Operator-update-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-update" title="Permalink"></a></h2><p>This package can also be used to write time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, <code>Zygote</code>-compatible way.</p><p>For example,</p><pre><code class="language-julia hljs">u = rand(N)
p = rand(N)
t = rand()

# out-of-place update
mat_update_func = (A, u, p, t) -&gt; t * (p * p&#39;)
sca_update_func = (a, u, p, t) -&gt; t * sum(p)

M = MatrixOperator(zero(N, N); update_func = mat_update_func)
α = ScalarOperator(zero(Float64); update_func = sca_update_func)

L = α * M
L = cache_operator(L, u)

# L is initialized with zero state
L * u == zeros(N) # true

# update operator state with `(u, p, t)`
L = update_coefficients(L, u, p, t)
# and multiply
L * u != zeros(N) # true

# updates state and evaluates L at (u, p, t)
L(u, p, t) != zeros(N) # true</code></pre><p>The out-of-place evaluation function <code>L(u, p, t)</code> calls <code>update_coefficients</code> under the hood, which recursively calls the <code>update_func</code> for each component <code>SciMLOperator</code>. Therefore, the out-of-place evaluation function is equivalent to calling <code>update_coefficients</code> followed by <code>Base.*</code>. Notice that the out-of-place evaluation does not return the updated operator.</p><p>On the other hand, the in-place evaluation function, <code>L(v, u, p, t)</code>, mutates <code>L</code>, and is equivalent to calling <code>update_coefficients!</code> followed by <code>mul!</code>. The in-place update behavior works the same way, with a few <code>&lt;!&gt;</code>s appended here and there. For example,</p><pre><code class="language-julia hljs">v = rand(N)
u = rand(N)
p = rand(N)
t = rand()

# in-place update
_A = rand(N, N)
_d = rand(N)
mat_update_func! = (A, u, p, t) -&gt; (copy!(A, _A); lmul!(t, A); nothing)
diag_update_func! = (diag, u, p, t) -&gt; copy!(diag, N)

M = MatrixOperator(zero(N, N); update_func! = mat_update_func!)
D = DiagonalOperator(zero(N); update_func! = diag_update_func!)

L = D * M
L = cache_operator(L, u)

# L is initialized with zero state
L * u == zeros(N) # true

# update L in-place
update_coefficients!(L, u, p, t)
# and multiply
mul!(v, u, p, t) != zero(N) # true

# updates L in-place, and evaluates at (u, p, t)
L(v, u, p, t) != zero(N) # true</code></pre><p>The update behavior makes this package flexible enough to be used in <code>OrdinaryDiffEq</code>. As the parameter object <code>p</code> is often reserved for sensitivity computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow update functions with arbitrary keyword arguments.</p><pre><code class="language-julia hljs">mat_update_func = (A, u, p, t; scale = 0.0) -&gt; scale * (p * p&#39;)

M = MatrixOperator(zero(N, N); update_func = mat_update_func,
    accepted_kwargs = (:state,))

M(u, p, t) == zeros(N) # true
M(u, p, t; scale = 1.0) != zero(N)</code></pre><h2 id="Interface-API-Reference"><a class="docs-heading-anchor" href="#Interface-API-Reference">Interface API Reference</a><a id="Interface-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.update_coefficients" href="#SciMLOperators.update_coefficients"><code>SciMLOperators.update_coefficients</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_coefficients(L, u, p, t; kwargs...)
</code></pre><p>Update the state of <code>L</code> based on <code>u</code>, input vector, <code>p</code> parameter object, <code>t</code>, and keyword arguments. Internally, <code>update_coefficients</code> calls the user-provided <code>update_func</code> method for every component operator in <code>L</code> with the positional arguments <code>(u, p, t)</code> and keyword arguments corresponding to the symbols provided to the operator via kwarg <code>accepted_kwargs</code>.</p><p>This method is out-of-place, i.e. fully non-mutating and <code>Zygote</code>-compatible.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The user-provided <code>update_func[!]</code> must not use <code>u</code> in its computation. Positional argument <code>(u, p, t)</code> to <code>update_func[!]</code> are passed down by <code>update_coefficients[!](L, u, p, t)</code>, where <code>u</code> is the input-vector to the composite <code>AbstractSciMLOperator</code>. For that reason, the values of <code>u</code>, or even shape, may not correspond to the input expected by <code>update_func[!]</code>. If an operator&#39;s state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in <code>FunctionOperator.</code> This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SciMLOperator

mat_update_func = (A, u, p, t; scale = 1.0) -&gt; p * p&#39; * scale * t

M = MatrixOperator(zeros(4,4); update_func = mat_update_func,
                   accepted_kwargs = (:state,))

L = M + IdentityOperator(4)

u = rand(4)
p = rand(4)
t = 1.0

L = update_coefficients(L, u, p, t; scale = 2.0)
L * u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.update_coefficients!" href="#SciMLOperators.update_coefficients!"><code>SciMLOperators.update_coefficients!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_coefficients!(L, u, p, t; kwargs...)
</code></pre><p>Update in-place the state of <code>L</code> based on <code>u</code>, input vector, <code>p</code> parameter object, <code>t</code>, and keyword arguments. Internally, <code>update_coefficients!</code> calls the user-provided mutating <code>update_func!</code> method for every component operator in <code>L</code> with the positional arguments <code>(u, p, t)</code> and keyword arguments corresponding to the symbols provided to the operator via kwarg <code>accepted_kwargs</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The user-provided <code>update_func[!]</code> must not use <code>u</code> in its computation. Positional argument <code>(u, p, t)</code> to <code>update_func[!]</code> are passed down by <code>update_coefficients[!](L, u, p, t)</code>, where <code>u</code> is the input-vector to the composite <code>AbstractSciMLOperator</code>. For that reason, the values of <code>u</code>, or even shape, may not correspond to the input expected by <code>update_func[!]</code>. If an operator&#39;s state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in <code>FunctionOperator.</code> This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SciMLOperator

_A = rand(4, 4)
mat_update_func! = (L, u, p, t; scale = 1.0) -&gt; copy!(A, _A)

M = MatrixOperator(zeros(4,4); update_func! = mat_update_func!)

L = M + IdentityOperator(4)

u = rand(4)
p = rand(4)
t = 1.0

update_coefficients!(L, u, p, t)
L * u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.cache_operator" href="#SciMLOperators.cache_operator"><code>SciMLOperators.cache_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cache_operator(L, u)
</code></pre><p>Allocate caches for <code>L</code> for in-place evaluation with <code>u</code>-like input vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.concretize" href="#SciMLOperators.concretize"><code>SciMLOperators.concretize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">concretize(L) -&gt; AbstractMatrix

concretize(L) -&gt; Number</code></pre><p>Convert <code>SciMLOperator</code> to a concrete type via eager fusion. This method is a no-op for types that are already concrete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L277-L284">source</a></section></article><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.isconstant" href="#SciMLOperators.isconstant"><code>SciMLOperators.isconstant</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconstant(_)
</code></pre><p>Checks if an <code>L</code>&#39;s state is constant or needs to be updated by calling <code>update_coefficients</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.iscached" href="#SciMLOperators.iscached"><code>SciMLOperators.iscached</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscached(L)
</code></pre><p>Checks whether <code>L</code> has preallocated caches for inplace evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L134">source</a></section><section><div><p>Check if <code>SciMLOperator</code> <code>L</code> has preallocated cache-arrays for in-place computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.issquare" href="#SciMLOperators.issquare"><code>SciMLOperators.issquare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Checks if <code>size(L, 1) == size(L, 2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L356-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.islinear" href="#SciMLOperators.islinear"><code>SciMLOperators.islinear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">islinear(_)
</code></pre><p>Checks if <code>L</code> is a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.isconvertible" href="#SciMLOperators.isconvertible"><code>SciMLOperators.isconvertible</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconvertible(L) -&gt; Bool</code></pre><p>Checks if <code>L</code> can be cheaply converted to an <code>AbstractMatrix</code> via eager fusion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_adjoint" href="#SciMLOperators.has_adjoint"><code>SciMLOperators.has_adjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_adjoint(L)
</code></pre><p>Check if <code>adjoint(L)</code> is lazily defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_expmv" href="#SciMLOperators.has_expmv"><code>SciMLOperators.has_expmv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_expmv(L)
</code></pre><p>Check if <code>expmv(L, u, t)</code>, equivalent to <code>exp(t * A) * u</code>, is defined for <code>Number</code> <code>t</code>, and <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_expmv!" href="#SciMLOperators.has_expmv!"><code>SciMLOperators.has_expmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_expmv!(L)
</code></pre><p>Check if <code>expmv!(v, L, u, t)</code>, equivalent to <code>mul!(v, exp(t * A), u)</code>, is defined for <code>Number</code> <code>t</code>, and <code>AbstractArray</code>s <code>u, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_exp" href="#SciMLOperators.has_exp"><code>SciMLOperators.has_exp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_exp(L)
</code></pre><p>Check if <code>exp(L)</code> is defined lazily defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_mul" href="#SciMLOperators.has_mul"><code>SciMLOperators.has_mul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_mul(L)
</code></pre><p>Check if <code>L * u</code> is defined for <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_mul!" href="#SciMLOperators.has_mul!"><code>SciMLOperators.has_mul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_mul!(L)
</code></pre><p>Check if <code>mul!(v, L, u)</code> is defined for <code>AbstractArray</code>s <code>u, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_ldiv" href="#SciMLOperators.has_ldiv"><code>SciMLOperators.has_ldiv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_ldiv(L)
</code></pre><p>Check if <code>L \ u</code> is defined for <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLOperators.has_ldiv!" href="#SciMLOperators.has_ldiv!"><code>SciMLOperators.has_ldiv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_ldiv!(L)
</code></pre><p>Check if <code>ldiv!(v, L, u)</code> is defined for <code>AbstractArray</code>s <code>u, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/3b14918422f09f2c4246a634ce23645c6b24d33f/src/interface.jl#L232">source</a></section></article><h2 id="Note-About-Affine-Operators"><a class="docs-heading-anchor" href="#Note-About-Affine-Operators">Note About Affine Operators</a><a id="Note-About-Affine-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Note-About-Affine-Operators" title="Permalink"></a></h2><p>Affine operators are operators that have the action <code>Q*x = A*x + b</code>. These operators have no matrix representation, since if there was, it would be a linear operator instead of an affine operator. You can only represent an affine operator as a linear operator in a dimension of one larger via the operation: <code>[A b] * [u;1]</code>, so it would require something modified to the input as well. As such, affine operators are a distinct generalization of linear operators.</p><p>While it seems like it might doom the idea of using matrix-free affine operators, it turns out that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy generalization of the standard convergence proofs. If Q is the affine operator <span>$Q(x) = Ax + b$</span>, then solving <span>$Qx = c$</span> is equivalent to solving <span>$Ax + b = c$</span> or <span>$Ax = c-b$</span>. If you now do this same “plug-and-chug” handling of the affine operator into the GMRES/CG/etc. convergence proofs, move the affine part to the rhs residual, and show it converges to solving <span>$Ax = c-b$</span>, and thus GMRES/CG/etc. solves <span>$Q(x) = c$</span> for an affine operator properly.</p><p>That same trick can be used mostly anywhere you would&#39;ve had a linear operator to extend the proof to affine operators, so then <span>$exp(A*t)*v$</span> operations via Krylov methods work for A being affine as well, and all sorts of things. Thus, affine operators have no matrix representation, but they are still compatible with essentially any Krylov method, which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.</p><h2 id="Note-about-keyword-arguments-to-update_coefficients!"><a class="docs-heading-anchor" href="#Note-about-keyword-arguments-to-update_coefficients!">Note about keyword arguments to <code>update_coefficients!</code></a><a id="Note-about-keyword-arguments-to-update_coefficients!-1"></a><a class="docs-heading-anchor-permalink" href="#Note-about-keyword-arguments-to-update_coefficients!" title="Permalink"></a></h2><p>In rare cases, an operator may be used in a context where additional state is expected to be provided to <code>update_coefficients!</code> beyond <code>u</code>, <code>p</code>, and <code>t</code>. In this case, the operator may accept this additional state through arbitrary keyword arguments to <code>update_coefficients!</code>. When the caller provides these, they will be recursively propagated downwards through composed operators just like <code>u</code>, <code>p</code>, and <code>t</code>, and provided to the operator. For the <a href="../premade_operators/">premade SciMLOperators</a>, one can specify the keyword arguments used by an operator with an <code>accepted_kwargs</code> argument (by default, none are passed).</p><p>In the below example, we create an operator that gleefully ignores <code>u</code>, <code>p</code>, and <code>t</code> and uses its own special scaling.</p><pre><code class="language-julia hljs">using SciMLOperators

γ = ScalarOperator(0.0;
    update_func = (a, u, p, t; my_special_scaling) -&gt; my_special_scaling,
    accepted_kwargs = (:my_special_scaling,))

# Update coefficients, then apply operator
update_coefficients!(γ, nothing, nothing, nothing; my_special_scaling = 7.0)
@show γ * [2.0]

# Use operator application form
@show γ([2.0], nothing, nothing; my_special_scaling = 5.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">γ * [2.0] = [14.0]
γ([2.0], nothing, nothing; my_special_scaling = 5.0) = [10.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sciml/">« Usage with <code>SciML</code> and beyond</a><a class="docs-footer-nextpage" href="../premade_operators/">Premade Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 18 October 2024 15:20">Friday 18 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
